var UZIP = {};
"object" == typeof module && (module.exports = UZIP);
UZIP.parse = function (b, a) {
  var c = UZIP.bin.readUshort,
    d = UZIP.bin.readUint,
    e,
    g = {},
    f = new Uint8Array(b);
  for (e = f.length - 4; 101010256 != d(f, e); ) e--;
  e = e + 4 + 4;
  var k = c(f, e);
  e += 2;
  c(f, e);
  e += 2;
  d(f, e);
  e += 4;
  e = d(f, e);
  for (var h = 0; h < k; h++) {
    d(f, e);
    e += 4;
    e += 4;
    e += 4;
    e += 4;
    d(f, e);
    e += 4;
    var l = d(f, e);
    e += 4;
    var m = d(f, e);
    e += 4;
    var r = c(f, e),
      v = c(f, e + 2),
      n = c(f, e + 4);
    e += 6;
    e += 8;
    var w = d(f, e);
    e += 4;
    e += r + v + n;
    UZIP._readLocal(f, w, g, l, m, a);
  }
  return g;
};
UZIP._readLocal = function (b, a, c, d, e, g) {
  var f = UZIP.bin.readUshort,
    k = UZIP.bin.readUint;
  k(b, a);
  a += 4;
  f(b, a);
  a += 2;
  f(b, a);
  a += 2;
  var h = f(b, a);
  a += 2;
  k(b, a);
  a += 4;
  k(b, a);
  a = a + 4 + 8;
  k = f(b, a);
  a += 2;
  var l = f(b, a);
  a += 2;
  f = UZIP.bin.readUTF8(b, a, k);
  a = a + k + l;
  if (g) c[f] = { size: e, csize: d };
  else if (((b = new Uint8Array(b.buffer, a)), 0 == h))
    c[f] = new Uint8Array(b.buffer.slice(a, a + d));
  else if (8 == h) (a = new Uint8Array(e)), UZIP.inflateRaw(b, a), (c[f] = a);
  else throw "unknown compression method: " + h;
};
UZIP.inflateRaw = function (b, a) {
  return UZIP.F.inflate(b, a);
};
UZIP.inflate = function (b, a) {
  return UZIP.inflateRaw(
    new Uint8Array(b.buffer, b.byteOffset + 2, b.length - 6),
    a,
  );
};
UZIP.deflate = function (b, a) {
  null == a && (a = { level: 6 });
  var c = 0,
    d = new Uint8Array(50 + Math.floor(1.1 * b.length));
  d[c] = 120;
  d[c + 1] = 156;
  c = UZIP.F.deflateRaw(b, d, c + 2, a.level);
  var e = UZIP.adler(b, 0, b.length);
  d[c + 0] = (e >>> 24) & 255;
  d[c + 1] = (e >>> 16) & 255;
  d[c + 2] = (e >>> 8) & 255;
  d[c + 3] = (e >>> 0) & 255;
  return new Uint8Array(d.buffer, 0, c + 4);
};
UZIP.deflateRaw = function (b, a) {
  null == a && (a = { level: 6 });
  var c = new Uint8Array(50 + Math.floor(1.1 * b.length)),
    d = UZIP.F.deflateRaw(b, c, d, a.level);
  return new Uint8Array(c.buffer, 0, d);
};
UZIP.encode = function (b, a) {
  null == a && (a = !1);
  var c = 0,
    d = UZIP.bin.writeUint,
    e = UZIP.bin.writeUshort,
    g = {},
    f;
  for (f in b) {
    var k = !UZIP._noNeed(f) && !a,
      h = b[f],
      l = UZIP.crc.crc(h, 0, h.length);
    g[f] = {
      cpr: k,
      usize: h.length,
      crc: l,
      file: k ? UZIP.deflateRaw(h) : h,
    };
  }
  for (f in g) c += g[f].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(f);
  c = new Uint8Array(c + 22);
  k = 0;
  var m = [];
  for (f in g) {
    var r = g[f];
    m.push(k);
    k = UZIP._writeHeader(c, k, f, r, 0);
  }
  h = 0;
  l = k;
  for (f in g)
    (r = g[f]), m.push(k), (k = UZIP._writeHeader(c, k, f, r, 1, m[h++]));
  g = k - l;
  d(c, k, 101010256);
  k = k + 4 + 4;
  e(c, k, h);
  k += 2;
  e(c, k, h);
  k += 2;
  d(c, k, g);
  d(c, k + 4, l);
  return c.buffer;
};
UZIP._noNeed = function (b) {
  b = b.split(".").pop().toLowerCase();
  return -1 != "png,jpg,jpeg,zip".indexOf(b);
};
UZIP._writeHeader = function (b, a, c, d, e, g) {
  var f = UZIP.bin.writeUint,
    k = UZIP.bin.writeUshort,
    h = d.file;
  f(b, a, 0 == e ? 67324752 : 33639248);
  a += 4;
  1 == e && (a += 2);
  k(b, a, 20);
  a += 2;
  k(b, a, 0);
  a += 2;
  k(b, a, d.cpr ? 8 : 0);
  a += 2;
  f(b, a, 0);
  a += 4;
  f(b, a, d.crc);
  a += 4;
  f(b, a, h.length);
  a += 4;
  f(b, a, d.usize);
  a += 4;
  k(b, a, UZIP.bin.sizeUTF8(c));
  a += 2;
  k(b, a, 0);
  a += 2;
  1 == e && ((a = a + 2 + 2 + 6), f(b, a, g), (a += 4));
  c = UZIP.bin.writeUTF8(b, a, c);
  a += c;
  0 == e && (b.set(h, a), (a += h.length));
  return a;
};
UZIP.crc = {
  table: (function () {
    for (var b = new Uint32Array(256), a = 0; 256 > a; a++) {
      for (var c = a, d = 0; 8 > d; d++)
        c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;
      b[a] = c;
    }
    return b;
  })(),
  update: function (b, a, c, d) {
    for (var e = 0; e < d; e++)
      b = UZIP.crc.table[(b ^ a[c + e]) & 255] ^ (b >>> 8);
    return b;
  },
  crc: function (b, a, c) {
    return UZIP.crc.update(4294967295, b, a, c) ^ 4294967295;
  },
};
UZIP.adler = function (b, a, c) {
  var d = 1,
    e = 0,
    g = a;
  for (a += c; g < a; ) {
    for (c = Math.min(g + 5552, a); g < c; ) (d += b[g++]), (e += d);
    d %= 65521;
    e %= 65521;
  }
  return (e << 16) | d;
};
UZIP.bin = {
  readUshort: function (b, a) {
    return b[a] | (b[a + 1] << 8);
  },
  writeUshort: function (b, a, c) {
    b[a] = c & 255;
    b[a + 1] = (c >> 8) & 255;
  },
  readUint: function (b, a) {
    return 16777216 * b[a + 3] + ((b[a + 2] << 16) | (b[a + 1] << 8) | b[a]);
  },
  writeUint: function (b, a, c) {
    b[a] = c & 255;
    b[a + 1] = (c >> 8) & 255;
    b[a + 2] = (c >> 16) & 255;
    b[a + 3] = (c >> 24) & 255;
  },
  readASCII: function (b, a, c) {
    for (var d = "", e = 0; e < c; e++) d += String.fromCharCode(b[a + e]);
    return d;
  },
  writeASCII: function (b, a, c) {
    for (var d = 0; d < c.length; d++) b[a + d] = c.charCodeAt(d);
  },
  pad: function (b) {
    return 2 > b.length ? "0" + b : b;
  },
  readUTF8: function (b, a, c) {
    for (var d = "", e, g = 0; g < c; g++)
      d += "%" + UZIP.bin.pad(b[a + g].toString(16));
    try {
      e = decodeURIComponent(d);
    } catch (f) {
      return UZIP.bin.readASCII(b, a, c);
    }
    return e;
  },
  writeUTF8: function (b, a, c) {
    for (var d = c.length, e = 0, g = 0; g < d; g++) {
      var f = c.charCodeAt(g);
      if (0 == (f & 4294967168)) (b[a + e] = f), e++;
      else if (0 == (f & 4294965248))
        (b[a + e] = 192 | (f >> 6)),
          (b[a + e + 1] = 128 | ((f >> 0) & 63)),
          (e += 2);
      else if (0 == (f & 4294901760))
        (b[a + e] = 224 | (f >> 12)),
          (b[a + e + 1] = 128 | ((f >> 6) & 63)),
          (b[a + e + 2] = 128 | ((f >> 0) & 63)),
          (e += 3);
      else if (0 == (f & 4292870144))
        (b[a + e] = 240 | (f >> 18)),
          (b[a + e + 1] = 128 | ((f >> 12) & 63)),
          (b[a + e + 2] = 128 | ((f >> 6) & 63)),
          (b[a + e + 3] = 128 | ((f >> 0) & 63)),
          (e += 4);
      else throw "e";
    }
    return e;
  },
  sizeUTF8: function (b) {
    for (var a = b.length, c = 0, d = 0; d < a; d++) {
      var e = b.charCodeAt(d);
      if (0 == (e & 4294967168)) c++;
      else if (0 == (e & 4294965248)) c += 2;
      else if (0 == (e & 4294901760)) c += 3;
      else if (0 == (e & 4292870144)) c += 4;
      else throw "e";
    }
    return c;
  },
};
UZIP.F = {};
UZIP.F.deflateRaw = function (b, a, c, d) {
  var e = [
      [0, 0, 0, 0, 0],
      [4, 4, 8, 4, 0],
      [4, 5, 16, 8, 0],
      [4, 6, 16, 16, 0],
      [4, 10, 16, 32, 0],
      [8, 16, 32, 32, 0],
      [8, 16, 128, 128, 0],
      [8, 32, 128, 256, 0],
      [32, 128, 258, 1024, 1],
      [32, 258, 258, 4096, 1],
    ][d],
    g = UZIP.F.U,
    f = UZIP.F._goodIndex,
    k = UZIP.F._putsE,
    h = 0;
  c <<= 3;
  var l = 0,
    m = b.length;
  if (0 == d) {
    for (; h < m; ) {
      var r = Math.min(65535, m - h);
      k(a, c, h + r == m ? 1 : 0);
      c = UZIP.F._copyExact(b, h, r, a, c + 8);
      h += r;
    }
    return c >>> 3;
  }
  k = g.lits;
  d = g.strt;
  var v = g.prev,
    n = 0,
    w = 0,
    x = 0,
    y = 0,
    t = 0;
  2 < m && ((t = UZIP.F._hash(b, 0)), (d[t] = 0));
  for (h = 0; h < m; h++) {
    r = t;
    if (h + 1 < m - 2) {
      t = UZIP.F._hash(b, h + 1);
      var p = (h + 1) & 32767;
      v[p] = d[t];
      d[t] = p;
    }
    if (l <= h) {
      (14e3 < n || 26697 < w) &&
        100 < m - h &&
        (l < h && ((k[n] = h - l), (n += 2), (l = h)),
        (c = UZIP.F._writeBlock(
          h == m - 1 || l == m ? 1 : 0,
          k,
          n,
          y,
          b,
          x,
          h - x,
          a,
          c,
        )),
        (n = w = y = 0),
        (x = h));
      p = 0;
      h < m - 2 &&
        (p = UZIP.F._bestMatch(b, h, v, r, Math.min(e[2], m - h), e[3]));
      if (0 != p) {
        r = p >>> 16;
        p &= 65535;
        var u = f(r, g.of0);
        g.lhst[257 + u]++;
        var q = f(p, g.df0);
        g.dhst[q]++;
        y += g.exb[u] + g.dxb[q];
        k[n] = (r << 23) | (h - l);
        k[n + 1] = (p << 16) | (u << 8) | q;
        n += 2;
        l = h + r;
      } else g.lhst[b[h]]++;
      w++;
    }
  }
  if (x != h || 0 == b.length)
    l < h && ((k[n] = h - l), (n += 2)),
      (c = UZIP.F._writeBlock(1, k, n, y, b, x, h - x, a, c));
  for (; 0 != (c & 7); ) c++;
  return c >>> 3;
};
UZIP.F._bestMatch = function (b, a, c, d, e, g) {
  var f = a & 32767,
    k = c[f],
    h = (f - k + 32768) & 32767;
  if (k == f || d != UZIP.F._hash(b, a - h)) return 0;
  for (
    var l = (d = 0), m = Math.min(32767, a);
    h <= m && 0 != --g && k != f;

  ) {
    if (0 == d || b[a + d] == b[a + d - h])
      if (((f = UZIP.F._howLong(b, a, h)), f > d)) {
        d = f;
        l = h;
        if (d >= e) break;
        h + 2 < f && (f = h + 2);
        for (var r = 0, v = 0; v < f - 2; v++) {
          var n = (a - h + v + 32768) & 32767,
            w = (n - c[n] + 32768) & 32767;
          w > r && ((r = w), (k = n));
        }
      }
    f = k;
    k = c[f];
    h += (f - k + 32768) & 32767;
  }
  return (d << 16) | l;
};
UZIP.F._howLong = function (b, a, c) {
  if (b[a] != b[a - c] || b[a + 1] != b[a + 1 - c] || b[a + 2] != b[a + 2 - c])
    return 0;
  var d = a,
    e = Math.min(b.length, a + 258);
  for (a += 3; a < e && b[a] == b[a - c]; ) a++;
  return a - d;
};
UZIP.F._hash = function (b, a) {
  return (((b[a] << 8) | b[a + 1]) + (b[a + 2] << 4)) & 65535;
};
UZIP.saved = 0;
UZIP.F._writeBlock = function (b, a, c, d, e, g, f, k, h) {
  var l = UZIP.F.U,
    m = UZIP.F._putsF,
    r = UZIP.F._putsE;
  l.lhst[256]++;
  var v = UZIP.F.getTrees();
  var n = v[0];
  var w = v[1];
  var x = v[2];
  var y = v[3];
  var t = v[4];
  var p = v[5];
  var u = v[6];
  v = v[7];
  var q = (0 == ((h + 3) & 7) ? 0 : 8 - ((h + 3) & 7)) + 32 + (f << 3),
    A =
      d + UZIP.F.contSize(l.fltree, l.lhst) + UZIP.F.contSize(l.fdtree, l.dhst);
  d = d + UZIP.F.contSize(l.ltree, l.lhst) + UZIP.F.contSize(l.dtree, l.dhst);
  d +=
    14 +
    3 * p +
    UZIP.F.contSize(l.itree, l.ihst) +
    (2 * l.ihst[16] + 3 * l.ihst[17] + 7 * l.ihst[18]);
  for (var z = 0; 286 > z; z++) l.lhst[z] = 0;
  for (z = 0; 30 > z; z++) l.dhst[z] = 0;
  for (z = 0; 19 > z; z++) l.ihst[z] = 0;
  q = q < A && q < d ? 0 : A < d ? 1 : 2;
  m(k, h, b);
  m(k, h + 1, q);
  h += 3;
  if (0 == q) {
    for (; 0 != (h & 7); ) h++;
    h = UZIP.F._copyExact(e, g, f, k, h);
  } else {
    if (1 == q) {
      var B = l.fltree;
      var C = l.fdtree;
    }
    if (2 == q) {
      UZIP.F.makeCodes(l.ltree, n);
      UZIP.F.revCodes(l.ltree, n);
      UZIP.F.makeCodes(l.dtree, w);
      UZIP.F.revCodes(l.dtree, w);
      UZIP.F.makeCodes(l.itree, x);
      UZIP.F.revCodes(l.itree, x);
      B = l.ltree;
      C = l.dtree;
      r(k, h, y - 257);
      h += 5;
      r(k, h, t - 1);
      h += 5;
      r(k, h, p - 4);
      h += 4;
      for (b = 0; b < p; b++) r(k, h + 3 * b, l.itree[(l.ordr[b] << 1) + 1]);
      h = UZIP.F._codeTiny(u, l.itree, k, h + 3 * p);
      h = UZIP.F._codeTiny(v, l.itree, k, h);
    }
    for (p = 0; p < c; p += 2) {
      b = a[p];
      u = b >>> 23;
      for (b = g + (b & 8388607); g < b; )
        h = UZIP.F._writeLit(e[g++], B, k, h);
      0 != u &&
        ((n = a[p + 1]),
        (b = n >> 16),
        (f = (n >> 8) & 255),
        (n &= 255),
        (h = UZIP.F._writeLit(257 + f, B, k, h)),
        r(k, h, u - l.of0[f]),
        (h += l.exb[f]),
        (h = UZIP.F._writeLit(n, C, k, h)),
        m(k, h, b - l.df0[n]),
        (h += l.dxb[n]),
        (g += u));
    }
    h = UZIP.F._writeLit(256, B, k, h);
  }
  return h;
};
UZIP.F._copyExact = function (b, a, c, d, e) {
  var g = e >>> 3;
  d[g] = c;
  d[g + 1] = c >>> 8;
  d[g + 2] = 255 - d[g];
  d[g + 3] = 255 - d[g + 1];
  g += 4;
  d.set(new Uint8Array(b.buffer, a, c), g);
  return e + ((c + 4) << 3);
};
UZIP.F.getTrees = function () {
  for (
    var b = UZIP.F.U,
      a = UZIP.F._hufTree(b.lhst, b.ltree, 15),
      c = UZIP.F._hufTree(b.dhst, b.dtree, 15),
      d = [],
      e = UZIP.F._lenCodes(b.ltree, d),
      g = [],
      f = UZIP.F._lenCodes(b.dtree, g),
      k = 0;
    k < d.length;
    k += 2
  )
    b.ihst[d[k]]++;
  for (k = 0; k < g.length; k += 2) b.ihst[g[k]]++;
  k = UZIP.F._hufTree(b.ihst, b.itree, 7);
  for (var h = 19; 4 < h && 0 == b.itree[(b.ordr[h - 1] << 1) + 1]; ) h--;
  return [a, c, k, e, f, h, d, g];
};
UZIP.F.getSecond = function (b) {
  for (var a = [], c = 0; c < b.length; c += 2) a.push(b[c + 1]);
  return a;
};
UZIP.F.nonZero = function (b) {
  for (var a = "", c = 0; c < b.length; c += 2)
    0 != b[c + 1] && (a += (c >> 1) + ",");
  return a;
};
UZIP.F.contSize = function (b, a) {
  for (var c = 0, d = 0; d < a.length; d++) c += a[d] * b[(d << 1) + 1];
  return c;
};
UZIP.F._codeTiny = function (b, a, c, d) {
  for (var e = 0; e < b.length; e += 2) {
    var g = b[e],
      f = b[e + 1];
    d = UZIP.F._writeLit(g, a, c, d);
    var k = 16 == g ? 2 : 17 == g ? 3 : 7;
    15 < g && (UZIP.F._putsE(c, d, f, k), (d += k));
  }
  return d;
};
UZIP.F._lenCodes = function (b, a) {
  for (var c = b.length; 2 != c && 0 == b[c - 1]; ) c -= 2;
  for (var d = 0; d < c; d += 2) {
    var e = b[d + 1],
      g = d + 3 < c ? b[d + 3] : -1,
      f = d + 5 < c ? b[d + 5] : -1,
      k = 0 == d ? -1 : b[d - 1];
    if (0 == e && g == e && f == e) {
      for (g = d + 5; g + 2 < c && b[g + 2] == e; ) g += 2;
      e = Math.min((g + 1 - d) >>> 1, 138);
      11 > e ? a.push(17, e - 3) : a.push(18, e - 11);
      d += 2 * e - 2;
    } else if (e == k && g == e && f == e) {
      for (g = d + 5; g + 2 < c && b[g + 2] == e; ) g += 2;
      e = Math.min((g + 1 - d) >>> 1, 6);
      a.push(16, e - 3);
      d += 2 * e - 2;
    } else a.push(e, 0);
  }
  return c >>> 1;
};
UZIP.F._hufTree = function (b, a, c) {
  var d = [],
    e = b.length,
    g = a.length,
    f = 0;
  for (f = 0; f < g; f += 2) (a[f] = 0), (a[f + 1] = 0);
  for (f = 0; f < e; f++) 0 != b[f] && d.push({ lit: f, f: b[f] });
  b = d.length;
  e = d.slice(0);
  if (0 == b) return 0;
  if (1 == b)
    return (
      (c = d[0].lit),
      (a[(c << 1) + 1] = 1),
      (a[((0 == c ? 1 : 0) << 1) + 1] = 1)
    );
  d.sort(function (a, b) {
    return a.f - b.f;
  });
  f = d[0];
  g = d[1];
  var k = 0,
    h = 1,
    l = 2;
  for (d[0] = { lit: -1, f: f.f + g.f, l: f, r: g, d: 0 }; h != b - 1; )
    (f = k != h && (l == b || d[k].f < d[l].f) ? d[k++] : d[l++]),
      (g = k != h && (l == b || d[k].f < d[l].f) ? d[k++] : d[l++]),
      (d[h++] = { lit: -1, f: f.f + g.f, l: f, r: g });
  d = UZIP.F.setDepth(d[h - 1], 0);
  d > c && (UZIP.F.restrictDepth(e, c, d), (d = c));
  for (f = 0; f < b; f++) a[(e[f].lit << 1) + 1] = e[f].d;
  return d;
};
UZIP.F.setDepth = function (b, a) {
  return -1 != b.lit
    ? (b.d = a)
    : Math.max(UZIP.F.setDepth(b.l, a + 1), UZIP.F.setDepth(b.r, a + 1));
};
UZIP.F.restrictDepth = function (b, a, c) {
  var d = 0,
    e = 1 << (c - a),
    g = 0;
  b.sort(function (a, b) {
    return b.d == a.d ? a.f - b.f : b.d - a.d;
  });
  for (d = 0; d < b.length; d++)
    if (b[d].d > a) {
      var f = b[d].d;
      b[d].d = a;
      g += e - (1 << (c - f));
    } else break;
  for (g >>>= c - a; 0 < g; )
    (f = b[d].d), f < a ? (b[d].d++, (g -= 1 << (a - f - 1))) : d++;
  for (; 0 <= d; d--) b[d].d == a && 0 > g && (b[d].d--, g++);
  0 != g && console.log("debt left");
};
UZIP.F._goodIndex = function (b, a) {
  var c = 0;
  a[c | 16] <= b && (c |= 16);
  a[c | 8] <= b && (c |= 8);
  a[c | 4] <= b && (c |= 4);
  a[c | 2] <= b && (c |= 2);
  a[c | 1] <= b && (c |= 1);
  return c;
};
UZIP.F._writeLit = function (b, a, c, d) {
  UZIP.F._putsF(c, d, a[b << 1]);
  return d + a[(b << 1) + 1];
};
UZIP.F.inflate = function (b, a) {
  var c = Uint8Array;
  if (3 == b[0] && 0 == b[1]) return a ? a : new c(0);
  var d = UZIP.F,
    e = d._bitsF,
    g = d._bitsE,
    f = d._decodeTiny,
    k = d.makeCodes,
    h = d.codes2map,
    l = d._get17,
    m = d.U,
    r = null == a;
  r && (a = new c((b.length >>> 2) << 3));
  for (var v = 0, n, w, x, y = 0, t = (w = 0), p = 0, u; 0 == v; )
    if (((v = e(b, p, 1)), (n = e(b, p + 1, 2)), (p += 3), 0 == n))
      0 != (p & 7) && (p += 8 - (p & 7)),
        (p = (p >>> 3) + 4),
        (n = b[p - 4] | (b[p - 3] << 8)),
        r && (a = UZIP.F._check(a, t + n)),
        a.set(new c(b.buffer, b.byteOffset + p, n), t),
        (p = (p + n) << 3),
        (t += n);
    else {
      r && (a = UZIP.F._check(a, t + 131072));
      1 == n && ((x = m.flmap), (u = m.fdmap), (y = 511), (w = 31));
      if (2 == n) {
        w = g(b, p, 5) + 257;
        n = g(b, p + 5, 5) + 1;
        x = g(b, p + 10, 4) + 4;
        p += 14;
        for (u = 0; 38 > u; u += 2) (m.itree[u] = 0), (m.itree[u + 1] = 0);
        y = 1;
        for (u = 0; u < x; u++) {
          var q = g(b, p + 3 * u, 3);
          m.itree[(m.ordr[u] << 1) + 1] = q;
          q > y && (y = q);
        }
        p += 3 * x;
        k(m.itree, y);
        h(m.itree, y, m.imap);
        x = m.lmap;
        u = m.dmap;
        p = f(m.imap, (1 << y) - 1, w + n, b, p, m.ttree);
        q = d._copyOut(m.ttree, 0, w, m.ltree);
        y = (1 << q) - 1;
        n = d._copyOut(m.ttree, w, n, m.dtree);
        w = (1 << n) - 1;
        k(m.ltree, q);
        h(m.ltree, q, x);
        k(m.dtree, n);
        h(m.dtree, n, u);
      }
      for (;;)
        if (((n = x[l(b, p) & y]), (p += n & 15), (q = n >>> 4), 0 == q >>> 8))
          a[t++] = q;
        else if (256 == q) break;
        else {
          n = t + q - 254;
          264 < q &&
            ((q = m.ldef[q - 257]),
            (n = t + (q >>> 3) + g(b, p, q & 7)),
            (p += q & 7));
          q = u[l(b, p) & w];
          p += q & 15;
          q = m.ddef[q >>> 4];
          var A = (q >>> 4) + e(b, p, q & 15);
          p += q & 15;
          for (r && (a = UZIP.F._check(a, t + 131072)); t < n; )
            (a[t] = a[t++ - A]),
              (a[t] = a[t++ - A]),
              (a[t] = a[t++ - A]),
              (a[t] = a[t++ - A]);
          t = n;
        }
    }
  return a.length == t ? a : a.slice(0, t);
};
UZIP.F._check = function (b, a) {
  var c = b.length;
  if (a <= c) return b;
  c = new Uint8Array(Math.max(c << 1, a));
  c.set(b, 0);
  return c;
};
UZIP.F._decodeTiny = function (b, a, c, d, e, g) {
  for (var f = UZIP.F._bitsE, k = UZIP.F._get17, h = 0; h < c; ) {
    var l = b[k(d, e) & a];
    e += l & 15;
    var m = l >>> 4;
    if (15 >= m) (g[h] = m), h++;
    else {
      var r = (l = 0);
      16 == m
        ? ((r = 3 + f(d, e, 2)), (e += 2), (l = g[h - 1]))
        : 17 == m
          ? ((r = 3 + f(d, e, 3)), (e += 3))
          : 18 == m && ((r = 11 + f(d, e, 7)), (e += 7));
      for (m = h + r; h < m; ) (g[h] = l), h++;
    }
  }
  return e;
};
UZIP.F._copyOut = function (b, a, c, d) {
  for (var e = 0, g = 0, f = d.length >>> 1; g < c; ) {
    var k = b[g + a];
    d[g << 1] = 0;
    d[(g << 1) + 1] = k;
    k > e && (e = k);
    g++;
  }
  for (; g < f; ) (d[g << 1] = 0), (d[(g << 1) + 1] = 0), g++;
  return e;
};
UZIP.F.makeCodes = function (b, a) {
  var c = UZIP.F.U,
    d = b.length,
    e,
    g;
  var f = c.bl_count;
  for (e = 0; e <= a; e++) f[e] = 0;
  for (e = 1; e < d; e += 2) f[b[e]]++;
  c = c.next_code;
  e = 0;
  f[0] = 0;
  for (g = 1; g <= a; g++) (e = (e + f[g - 1]) << 1), (c[g] = e);
  for (f = 0; f < d; f += 2) (e = b[f + 1]), 0 != e && ((b[f] = c[e]), c[e]++);
};
UZIP.F.codes2map = function (b, a, c) {
  for (var d = b.length, e = UZIP.F.U.rev15, g = 0; g < d; g += 2)
    if (0 != b[g + 1]) {
      var f = b[g + 1],
        k = ((g >> 1) << 4) | f,
        h = a - f;
      f = b[g] << h;
      for (h = f + (1 << h); f != h; ) (c[e[f] >>> (15 - a)] = k), f++;
    }
};
UZIP.F.revCodes = function (b, a) {
  for (var c = UZIP.F.U.rev15, d = 15 - a, e = 0; e < b.length; e += 2)
    b[e] = c[b[e] << (a - b[e + 1])] >>> d;
};
UZIP.F._putsE = function (b, a, c) {
  c <<= a & 7;
  a >>>= 3;
  b[a] |= c;
  b[a + 1] |= c >>> 8;
};
UZIP.F._putsF = function (b, a, c) {
  c <<= a & 7;
  a >>>= 3;
  b[a] |= c;
  b[a + 1] |= c >>> 8;
  b[a + 2] |= c >>> 16;
};
UZIP.F._bitsE = function (b, a, c) {
  return ((b[a >>> 3] | (b[(a >>> 3) + 1] << 8)) >>> (a & 7)) & ((1 << c) - 1);
};
UZIP.F._bitsF = function (b, a, c) {
  return (
    ((b[a >>> 3] | (b[(a >>> 3) + 1] << 8) | (b[(a >>> 3) + 2] << 16)) >>>
      (a & 7)) &
    ((1 << c) - 1)
  );
};
UZIP.F._get17 = function (b, a) {
  return (
    (b[a >>> 3] | (b[(a >>> 3) + 1] << 8) | (b[(a >>> 3) + 2] << 16)) >>>
    (a & 7)
  );
};
UZIP.F._get25 = function (b, a) {
  return (
    (b[a >>> 3] |
      (b[(a >>> 3) + 1] << 8) |
      (b[(a >>> 3) + 2] << 16) |
      (b[(a >>> 3) + 3] << 24)) >>>
    (a & 7)
  );
};
UZIP.F.U = (function () {
  var b = Uint16Array,
    a = Uint32Array;
  return {
    next_code: new b(16),
    bl_count: new b(16),
    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    of0: [
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999,
    ],
    exb: [
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
      5, 5, 5, 0, 0, 0, 0,
    ],
    ldef: new b(32),
    df0: [
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535,
      65535,
    ],
    dxb: [
      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
      11, 11, 12, 12, 13, 13, 0, 0,
    ],
    ddef: new a(32),
    flmap: new b(512),
    fltree: [],
    fdmap: new b(32),
    fdtree: [],
    lmap: new b(32768),
    ltree: [],
    ttree: [],
    dmap: new b(32768),
    dtree: [],
    imap: new b(512),
    itree: [],
    rev15: new b(32768),
    lhst: new a(286),
    dhst: new a(30),
    ihst: new a(19),
    lits: new a(15e3),
    strt: new b(65536),
    prev: new b(32768),
  };
})();
(function () {
  function b(a, b, c) {
    for (; 0 != b--; ) a.push(0, c);
  }
  for (var a = UZIP.F.U, c = 0; 32768 > c; c++) {
    var d = c;
    d = ((d & 2863311530) >>> 1) | ((d & 1431655765) << 1);
    d = ((d & 3435973836) >>> 2) | ((d & 858993459) << 2);
    d = ((d & 4042322160) >>> 4) | ((d & 252645135) << 4);
    d = ((d & 4278255360) >>> 8) | ((d & 16711935) << 8);
    a.rev15[c] = ((d >>> 16) | (d << 16)) >>> 17;
  }
  for (c = 0; 32 > c; c++)
    (a.ldef[c] = (a.of0[c] << 3) | a.exb[c]),
      (a.ddef[c] = (a.df0[c] << 4) | a.dxb[c]);
  b(a.fltree, 144, 8);
  b(a.fltree, 112, 9);
  b(a.fltree, 24, 7);
  b(a.fltree, 8, 8);
  UZIP.F.makeCodes(a.fltree, 9);
  UZIP.F.codes2map(a.fltree, 9, a.flmap);
  UZIP.F.revCodes(a.fltree, 9);
  b(a.fdtree, 32, 5);
  UZIP.F.makeCodes(a.fdtree, 5);
  UZIP.F.codes2map(a.fdtree, 5, a.fdmap);
  UZIP.F.revCodes(a.fdtree, 5);
  b(a.itree, 19, 0);
  b(a.ltree, 286, 0);
  b(a.dtree, 30, 0);
  b(a.ttree, 320, 0);
})();
